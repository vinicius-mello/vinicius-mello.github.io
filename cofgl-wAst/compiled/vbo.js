// Generated by CoffeeScript 1.8.0
(function() {
  var Buffer, InterleavedRemoteBuffer, LocalBuffer, RemoteBuffer, VertexBufferObject, root,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Buffer = (function() {
    function Buffer(name, size) {
      var gl;
      gl = cofgl.engine.gl;
      this.name = name;
      this.size = size;
      this.isIndex = name === '__index__';
      this.isSpecial = name[0] === '_';
      this.type = this.isIndex ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;
      if (this.isIndex) {
        this.elementType = gl.UNSIGNED_SHORT;
        this.elementSize = 2;
      } else {
        this.elementType = gl.FLOAT;
        this.elementSize = 4;
      }
    }

    return Buffer;

  })();

  LocalBuffer = (function(_super) {
    __extends(LocalBuffer, _super);

    LocalBuffer.prototype.isOnDevice = false;

    LocalBuffer.prototype.isInterleavedBuffer = false;

    function LocalBuffer(name, size, vertices) {
      var gl;
      LocalBuffer.__super__.constructor.call(this, name, size);
      gl = cofgl.engine.gl;
      if (this.elementType === gl.UNSIGNED_SHORT) {
        this.vertices = new Uint16Array(vertices);
      } else {
        this.vertices = new Float32Array(vertices);
      }
    }

    return LocalBuffer;

  })(Buffer);

  RemoteBuffer = (function(_super) {
    __extends(RemoteBuffer, _super);

    RemoteBuffer.prototype.isOnDevice = true;

    function RemoteBuffer(name, size, id) {
      RemoteBuffer.__super__.constructor.call(this, name, size);
      this.id = id;
      this.stride = 0;
      this.offset = 0;
    }

    return RemoteBuffer;

  })(Buffer);

  InterleavedRemoteBuffer = (function(_super) {
    __extends(InterleavedRemoteBuffer, _super);

    InterleavedRemoteBuffer.prototype.isInterleavedBuffer = true;

    function InterleavedRemoteBuffer(name, size, stride, offset) {
      InterleavedRemoteBuffer.__super__.constructor.call(this, name, size, null);
      this.stride = stride;
      this.offset = offset;
    }

    return InterleavedRemoteBuffer;

  })(RemoteBuffer);

  VertexBufferObject = (function(_super) {
    __extends(VertexBufferObject, _super);

    VertexBufferObject.withStack('vbo');

    function VertexBufferObject(drawMode, count, options) {
      var _ref;
      if (options == null) {
        options = {};
      }
      this.drawMode = cofgl.engine.gl[drawMode];
      this.count = count;
      this.interleaved = (_ref = options.interleaved) != null ? _ref : true;
      this.buffers = {};
      this.uploaded = false;
    }

    VertexBufferObject.prototype.addIndexBuffer = function(vertices) {
      return this.addBuffer('__index__', 1, vertices);
    };

    VertexBufferObject.prototype.addBuffer = function(name, size, vertices) {
      var _base;
      return (_base = this.buffers)[name] != null ? _base[name] : _base[name] = new LocalBuffer(name, size, vertices);
    };

    VertexBufferObject.prototype.uploadInterleaved = function() {
      var buffer, bufferOffset, count, dstOffset, gl, i, id, j, name, offset, offsets, srcOffset, stride, vertices, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2, _ref3, _results;
      gl = cofgl.engine.gl;
      stride = 0;
      count = 0;
      offsets = [];
      _ref = this.buffers;
      for (name in _ref) {
        buffer = _ref[name];
        if (buffer.isSpecial) {
          continue;
        }
        offsets.push([name, stride, buffer]);
        stride += buffer.size;
        if (count === 0) {
          count = buffer.vertices.length / buffer.size;
        }
      }
      vertices = new Float32Array(count * stride);
      for (i = _i = 0; 0 <= count ? _i < count : _i > count; i = 0 <= count ? ++_i : --_i) {
        dstOffset = stride * i;
        for (_j = 0, _len = offsets.length; _j < _len; _j++) {
          _ref1 = offsets[_j], name = _ref1[0], bufferOffset = _ref1[1], buffer = _ref1[2];
          srcOffset = i * buffer.size;
          for (j = _k = 0, _ref2 = buffer.size; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; j = 0 <= _ref2 ? ++_k : --_k) {
            vertices[dstOffset + bufferOffset + j] = buffer.vertices[srcOffset + j];
          }
        }
      }
      id = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, id);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
      this.buffers.__interleaved__ = new RemoteBuffer('__interleaved__', buffer.size, id);
      _results = [];
      for (_l = 0, _len1 = offsets.length; _l < _len1; _l++) {
        _ref3 = offsets[_l], name = _ref3[0], offset = _ref3[1], buffer = _ref3[2];
        _results.push(this.buffers[name] = new InterleavedRemoteBuffer(name, buffer.size, stride * buffer.elementSize, offset * buffer.elementSize));
      }
      return _results;
    };

    VertexBufferObject.prototype.uploadSeparateBuffers = function() {
      var buffer, bufferType, gl, id, name, _ref, _results;
      gl = cofgl.engine.gl;
      _ref = this.buffers;
      _results = [];
      for (name in _ref) {
        buffer = _ref[name];
        if (buffer.isInterleavedBuffer || buffer.isOnDevice) {
          continue;
        }
        bufferType = buffer.type;
        id = gl.createBuffer();
        gl.bindBuffer(bufferType, id);
        gl.bufferData(bufferType, buffer.vertices, gl.STATIC_DRAW);
        _results.push(this.buffers[name] = new RemoteBuffer(name, buffer.size, id));
      }
      return _results;
    };

    VertexBufferObject.prototype.upload = function() {
      if (!this.uploaded) {
        if (this.interleaved) {
          this.uploadInterleaved();
        }
        return this.uploadSeparateBuffers();
      }
    };

    VertexBufferObject.prototype.destroy = function() {
      var buffer, gl, name, _ref;
      gl = cofgl.engine.gl;
      _ref = this.buffers;
      for (name in _ref) {
        buffer = _ref[name];
        if (buffer.isOnDevice && (buffer.id != null)) {
          gl.deleteBuffer(buffer.id);
        }
      }
      this.buffers = {};
      return this.count = 0;
    };

    VertexBufferObject.prototype.bind = function() {
      var buffer, drawElements, gl, loc, locsToDisable, name, shader, _ref;
      gl = cofgl.engine.gl;
      shader = cofgl.Shader.top();
      drawElements = this.buffers.__index__ != null;
      locsToDisable = [];
      if (buffer = this.buffers.__interleaved__) {
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer.id);
      }
      _ref = this.buffers;
      for (name in _ref) {
        buffer = _ref[name];
        if (buffer.isSpecial) {
          continue;
        }
        if (buffer.id !== null) {
          gl.bindBuffer(gl.ARRAY_BUFFER, buffer.id);
        }
        loc = shader.getAttribLocation(name);
        if (loc >= 0) {
          gl.vertexAttribPointer(loc, buffer.size, buffer.elementType, false, buffer.stride, buffer.offset);
          gl.enableVertexAttribArray(loc);
          locsToDisable.push(loc);
        }
      }
      if (drawElements) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffers.__index__.id);
        return gl.drawElements(this.drawMode, this.count, gl.UNSIGNED_SHORT, 0);
      } else {
        return gl.drawArrays(this.drawMode, 0, this.count);
      }
    };

    VertexBufferObject.prototype.unbind = function() {
      var buffer, gl, loc, name, shader, _ref, _results;
      gl = cofgl.engine.gl;
      shader = cofgl.Shader.top();
      _ref = this.buffers;
      _results = [];
      for (name in _ref) {
        buffer = _ref[name];
        if (!buffer.isSpecial) {
          loc = shader.getAttribLocation(name);
          if (loc >= 0) {
            _results.push(gl.disableVertexAttribArray(loc));
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    VertexBufferObject.prototype.draw = function() {
      var drawElements, gl;
      if (!this.count) {
        return;
      }
      gl = cofgl.engine.gl;
      this.push();
      drawElements = this.buffers.__index__ != null;
      cofgl.engine.flushUniforms();
      if (drawElements) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffers.__index__.id);
        gl.drawElements(this.drawMode, this.count, gl.UNSIGNED_SHORT, 0);
      } else {
        gl.drawArrays(this.drawMode, 0, this.count);
      }
      return this.pop();
    };

    return VertexBufferObject;

  })(cofgl.ContextObject);

  root = self.cofgl != null ? self.cofgl : self.cofgl = {};

  root.VertexBufferObject = VertexBufferObject;

}).call(this);
