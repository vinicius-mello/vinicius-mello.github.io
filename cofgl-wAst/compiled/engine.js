// Generated by CoffeeScript 1.8.0
(function() {
  var Engine, MatrixStack, clear, makeGLContext, requestAnimationFrame, root;

  requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;

  makeGLContext = function(canvas, debug, options) {
    var ctx, e;
    try {
      ctx = canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options);
    } catch (_error) {
      e = _error;
      alert("Error: This browser does not support WebGL");
      return null;
    }
    if (debug) {
      ctx = WebGLDebugUtils.makeDebugContext(ctx, function(err, funcName, args) {
        var errorStr, x;
        args = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = args.length; _i < _len; _i++) {
            x = args[_i];
            _results.push(x);
          }
          return _results;
        })();
        errorStr = WebGLDebugUtils.glEnumToString(err);
        console.error("WebGL Error: func=" + funcName + " args=", args, " error=", errorStr);
        if (typeof console.trace === "function") {
          console.trace();
        }
        throw "Aborting rendering after critical WebGL error";
      });
    }
    return ctx;
  };

  clear = function(color) {
    var gl;
    if (color == null) {
      color = cofgl.floatColorFromHex('#ffffff');
    }
    gl = cofgl.engine.gl;
    gl.clearColor(color[0], color[1], color[2], color[3]);
    return gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  };

  Engine = (function() {
    function Engine(canvas, debug) {
      if (debug == null) {
        debug = false;
      }
      this.debug = debug;
      this.canvas = canvas;
      this.throbber = $('<img src=assets/throbber.gif id=throbber>').appendTo('body').hide();
      this.throbberLevel = 0;
      this.FPSDisplay = cofgl.debugPanel.addDisplay('FPS');
      this.gl = makeGLContext(canvas, this.debug, {
        antialias: false
      });
      this.width = this.canvas.width;
      this.height = this.canvas.height;
      this.aspect = this.canvas.width / this.canvas.height;
      this.gl.enable(this.gl.DEPTH_TEST);
      this.gl.depthFunc(this.gl.LEQUAL);
      this.gl.enable(this.gl.CULL_FACE);
      this.gl.cullFace(this.gl.BACK);
      this.gl.enable(this.gl.BLEND);
      this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
      this.model = new MatrixStack;
      this.view = new MatrixStack;
      this.projection = new MatrixStack;
      this._uniformVersion = 0;
      this.markMVPDirty();
      console.debug('Render canvas =', this.canvas);
      console.debug('WebGL context =', this.gl);
    }

    Engine.prototype.pushThrobber = function() {
      if (this.throbberLevel++ === 0) {
        return this.throbber.fadeIn();
      }
    };

    Engine.prototype.popThrobber = function() {
      if (--this.throbberLevel === 0) {
        return this.throbber.fadeOut();
      }
    };

    Engine.prototype.markMVPDirty = function() {
      this._uniformVersion++;
      this._frustum = null;
      this._mvp = null;
      this._modelView = null;
      this._normal = null;
      this._iview = null;
      return this._ivp = null;
    };

    Engine.prototype.getModelView = function() {
      return this._modelView != null ? this._modelView : this._modelView = mat4.multiply(this.view.top, this.model.top);
    };

    Engine.prototype.getModelViewProjection = function() {
      return this._mvp != null ? this._mvp : this._mvp = mat4.multiply(this.projection.top, this.getModelView(), mat4.create());
    };

    Engine.prototype.getNormal = function() {
      return this._normal = mat4.toInverseMat3(this.model.top);
    };

    Engine.prototype.getCurrentFrustum = function() {
      return this._frustum != null ? this._frustum : this._frustum = new cofgl.Frustum(this.getModelViewProjection());
    };

    Engine.prototype.getInverseView = function() {
      return this._iview != null ? this._iview : this._iview = mat4.inverse(this.view.top, mat4.create());
    };

    Engine.prototype.getInverseViewProjection = function() {
      var viewproj;
      viewproj = mat4.multiply(this.projection.top, this.view.top, mat4.create());
      return this._ivp != null ? this._ivp : this._ivp = mat4.inverse(viewproj);
    };

    Engine.prototype.getCameraPos = function() {
      var iview;
      iview = this.getInverseView();
      return vec3.create([iview[12], iview[13], iview[14]]);
    };

    Engine.prototype.getForward = function() {
      return vec3.create([-this.view.top[2], -this.view.top[6], -this.view.top[10]]);
    };

    Engine.prototype.flushUniforms = function() {
      var shader;
      shader = cofgl.Shader.top();
      if (shader._uniformVersion === this._uniformVersion) {
        return;
      }
      shader.uniform2f("uViewportSize", this.width, this.height);
      shader.uniformMatrix4fv("uModelMatrix", this.model.top);
      shader.uniformMatrix4fv("uViewMatrix", this.view.top);
      shader.uniformMatrix4fv("uModelViewMatrix", this.getModelView());
      shader.uniformMatrix4fv("uProjectionMatrix", this.projection.top);
      shader.uniformMatrix4fv("uModelViewProjectionMatrix", this.getModelViewProjection());
      shader.uniformMatrix3fv("uNormalMatrix", this.getNormal());
      return shader._uniformVersion = this._uniformVersion;
    };

    Engine.prototype.mainloop = function(iterate) {
      var lastTimestamp, step;
      lastTimestamp = null;
      step = (function(_this) {
        return function(timestamp) {
          var dt;
          if (lastTimestamp == null) {
            lastTimestamp = timestamp;
            return requestAnimationFrame(step);
          } else {
            dt = timestamp - lastTimestamp;
            _this.FPSDisplay.setText(Math.floor(1000 / dt) + 'FPS');
            iterate(dt / 1000.0);
            lastTimestamp = timestamp;
            return requestAnimationFrame(step);
          }
        };
      })(this);
      return requestAnimationFrame(step);
    };

    return Engine;

  })();

  MatrixStack = (function() {
    function MatrixStack() {
      this.top = mat4.identity();
      this.stack = [];
    }

    MatrixStack.prototype.set = function(value) {
      this.top = value;
      return cofgl.engine.markMVPDirty();
    };

    MatrixStack.prototype.identity = function() {
      return this.set(mat4.identity());
    };

    MatrixStack.prototype.multiply = function(mat) {
      mat4.multiply(this.top, mat);
      return cofgl.engine.markMVPDirty();
    };

    MatrixStack.prototype.translate = function(vector) {
      mat4.translate(this.top, vector);
      return cofgl.engine.markMVPDirty();
    };

    MatrixStack.prototype.rotate = function(angle, axis) {
      mat4.rotate(this.top, angle, axis);
      return cofgl.engine.markMVPDirty();
    };

    MatrixStack.prototype.scale = function(vector) {
      mat4.scale(this.top, vector);
      return cofgl.engine.markMVPDirty();
    };

    MatrixStack.prototype.push = function(mat) {
      if (mat == null) {
        mat = null;
      }
      if (!mat) {
        this.stack.push(mat4.create(mat));
        this.top = mat4.create(mat);
      } else {
        this.stack.push(mat4.create(mat));
      }
      return null;
    };

    MatrixStack.prototype.pop = function() {
      this.top = this.stack.pop();
      return cofgl.engine.markMVPDirty();
    };

    return MatrixStack;

  })();

  root = self.cofgl != null ? self.cofgl : self.cofgl = {};

  root.Engine = Engine;

  root.clear = clear;

}).call(this);
