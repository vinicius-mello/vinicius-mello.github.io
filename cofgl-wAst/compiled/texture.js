// Generated by CoffeeScript 1.8.0
(function() {
  var Texture, TextureSlice, createAndPushTexture, root,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  createAndPushTexture = function(width, height, options, image) {
    var filter, filtering, gl, mipmapFilter, storedHeight, storedWidth, texture, _ref, _ref1, _ref2, _ref3;
    if (options == null) {
      options = {};
    }
    if (image == null) {
      image = null;
    }
    gl = cofgl.engine.gl;
    if ((_ref = options.forcePOT) != null ? _ref : true) {
      storedWidth = cofgl.nextPowerOfTwo(width);
      storedHeight = cofgl.nextPowerOfTwo(height);
    } else {
      storedWidth = width;
      storedHeight = height;
    }
    texture = new Texture(width, height, storedWidth, storedHeight, 0, 0);
    texture.unit = (_ref1 = options.unit) != null ? _ref1 : 0;
    texture.id = gl.createTexture();
    texture.push();
    filtering = (_ref2 = options.filtering) != null ? _ref2 : 'LINEAR';
    filter = mipmapFilter = gl[filtering];
    if ((_ref3 = options.flipY) != null ? _ref3 : true) {
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    }
    if (image) {
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
    } else {
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    }
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
    if (options.clampToEdge) {
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    }
    if (options.mipmaps) {
      mipmapFilter = gl["" + filtering + "_MIPMAP_" + filtering];
    }
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, mipmapFilter);
    if (options.mipmaps) {
      gl.generateMipmap(gl.TEXTURE_2D);
    }
    return texture;
  };

  Texture = (function(_super) {
    __extends(Texture, _super);

    Texture.withStack('texture');

    function Texture(width, height, storedWidth, storedHeight, offsetX, offsetY) {
      this.id = -1;
      this.unit = 0;
      this.width = width;
      this.height = height;
      this.storedWidth = storedWidth;
      this.storedHeight = storedHeight;
      this.offsetX = offsetX;
      this.offsetY = offsetY;
      this.parent = null;
      this.name = "uTexture";
    }

    Texture.prototype.bind = function() {
      var gl, shader;
      gl = cofgl.engine.gl;
      gl.activeTexture(gl.TEXTURE0 + this.unit);
      gl.bindTexture(gl.TEXTURE_2D, this.id);
      shader = cofgl.Shader.top();
      if (shader) {
        return shader.uniform1i(this.name, this.unit);
      }
    };

    Texture.prototype.unbind = function() {
      var gl;
      gl = cofgl.engine.gl;
      return gl.bindTexture(gl.TEXTURE_2D, null);
    };

    Texture.prototype.destroy = function() {
      if (this.parent) {
        return;
      }
      return cofgl.engine.gl.deleteTexture(this.id);
    };

    Texture.prototype.scaleCoords = function(coords) {
      var coord, facX, facY, idx, offX, offY, rv, _i, _len;
      facX = this.width / this.storedWidth;
      facY = this.height / this.storedHeight;
      offX = this.offsetX / this.storedWidth;
      offY = this.offsetY / this.storedHeight;
      rv = new Array(coords.length);
      for (idx = _i = 0, _len = coords.length; _i < _len; idx = ++_i) {
        coord = coords[idx];
        if (idx % 2 === 0) {
          coord = coord * facX + offX;
        } else {
          coord = coord * facY + offY;
        }
        rv[idx] = coord;
      }
      return rv;
    };

    Texture.prototype.slice = function(x, y, width, height) {
      return new TextureSlice(this, this.offsetX + x, this.offsetY + y, width, height);
    };

    Texture.fromSize = function(width, height, options) {
      var gl, texture;
      if (options == null) {
        options = {};
      }
      gl = cofgl.engine.gl;
      texture = createAndPushTexture(width, height, options);
      if (!options.pushTexture) {
        texture.pop();
      }
      return texture;
    };

    Texture.fromImage = function(image, options) {
      var filename, texture;
      if (options == null) {
        options = {};
      }
      texture = createAndPushTexture(image.width, image.height, options, image);
      filename = cofgl.autoShortenFilename(image.src || '<dynamic>');
      console.debug("Created texture from '" + filename + "' [dim=" + image.width + "x" + image.height + ", filtering=" + (options.filtering || 'LINEAR') + "] ->", texture);
      texture.pop();
      return texture;
    };

    return Texture;

  })(cofgl.ContextObject);

  TextureSlice = (function(_super) {
    __extends(TextureSlice, _super);

    function TextureSlice(texture, offsetX, offsetY, width, height) {
      TextureSlice.__super__.constructor.call(this, width, height, texture.storedWidth, texture.storedHeight, offsetX, offsetY);
      this.parent = texture;
      this.id = texture.id;
      this.unit = texture.unit;
    }

    return TextureSlice;

  })(Texture);

  root = self.cofgl != null ? self.cofgl : self.cofgl = {};

  root.Texture = Texture;

}).call(this);
